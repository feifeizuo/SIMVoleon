See also

    docs/todo.txt

for suggestions for major improvements and new features.

========================================================================

001 The set of 2D texture slices doesn't seem to cover the full
    extents of the bounding box.

    To reproduce, look at a very small volume data set. I noticed it
    on the 41^3 "marschnerlobb" set. To debug this, it would probably
    be wise to use an even smaller set to see the problem more
    clearly.

    20030627 mortene.

    UPDATE 20040212 mortene: handegar committed a fix for this, check
    if it now works 100% correctly.

========================================================================

002 When setting numSlices > actual depth, it seems more slices than
    the depth are rendered.

    This seems pointless. Investigate.

    20030702 mortene.
    
    UPDATE 20040907 handegar: When rendering using 3D textures, this
    might be a good thing, as an increase in number of slices (beyond
    the actual depth) results in smoother volume surfaces and better
    image quality due to the linear filtering. We might consider
    clamping the number of slices when rendering with 2D textures,
    though (unless we implement some kind of interpolation technique for
    the 'in between' 2D ortho slices).

========================================================================

003 SoVolumeRender with 3D-textures fails on Solaris.

    Tingdahl reported that when running their app on a Solaris box and
    remote displaying it on a Linux box, slices came up white instead
    of textured.

    (Could this simply be due to the disable-all-OpenGL-non-1.0-features
    activation upon remote rendering?)

    20040616 mortene.

========================================================================

004 Invisible pages made visible by palette changes are not rendered.

    Happens at least when rendering SoVolumeRender with paletted 2D
    textures.

    20040622 mortene.

========================================================================

006 Support for SoVolumeRender::viewAlignedSlices not implemented.

    At least one potential client would use this. Should be simple to
    fix.

    handegar suggests that we can simply do it by forcing 2D textures,
    which sounds like a good idea. Can probably be done simply by
    changing the code around line 493 of VolumeRender.cpp to

         if (cc_glglue_has_3d_textures(glue) && 
                !CvrUtil::force2DTextureRendering() && 
                this->viewAlignedSlices.getValue()) {
                ...

    ..but do some testing with this before committing.

    One problem: SoVolumeRender::viewAlignedSlices is FALSE by
    default, i.e. programmers should explicitly change it to TRUE to
    get 3D textures -- that's how it seems to be documented to work
    for TGS VolumeViz.

    20040702 mortene.

========================================================================

007 Doxygen documentation should "connect" to Coin ditto.

    As it is now, the Doxygen doc generation for SIM Voleon doesn't
    know about the Coin classes, which means e.g. the class hierarchy
    view is pretty worthless, and no links to doc of Coin classes are
    made.

    Need to check whether or not Doxygen supports ways to include data
    from separately generated doc. If not, I don't know what to do
    about this. :-/

    Perhaps it would work to separate out the file list from
    docs/simvoleon.doxygen.in, then integrate this into a larger "Coin
    family" doxygen config file for doc generation http://for
    doc.coin3d.org.

    20040708 mortene.

    UPDATE 20040708 mortene: Gerhard Reitmayr says it is indeed
    possible to connect together several Doxygen documentation
    generations, and provided this link for doc on this feature:

        http://www.stack.nl/~dimitri/doxygen/doxytag_usage.html

========================================================================

008 Mac OS X configure & build set-up is sub-par.

    Should match Coin's ditto.

    20040710 mortene.

========================================================================

009 Implement support for SoVolumeData::storageHint MEMORY.

    Should now be straightforward with 2D-texture based rendering, at
    least: just delete texture immediately after rendering the quad in
    Cvr2DTexSubPage.

    20040716 mortene.

========================================================================

010 Normals are ignored for the SoVolume[Face|triangle]Set family.
    
    Lighting will not be correct for polygons that intersect the
    volume as normals are ignored.

    20040722 handegar.

========================================================================

012 There are seams between texture sub-cubes (3D textures) and
    texture sub-pages (2D textures) of a volume.

    To reproduce, look at a volume with 2D texturing (it is much
    harder to spot for 3D texturing) and a transfer function with
    sharp color changes, with interpolation set to "LINEAR". The seams
    then visible is caused by the textures _not_ interpolating to the
    neighboring row of texels at the texture borders.

    This is a medium priority bug.

    It is not trivial to fix: we need to generate textures that
    "borrows" rows / columns from neighboring data blocks for the
    texture borders, then shrink the textures so that only the "inner"
    part (i.e. excluding the 1-texel borders) are used for the
    textured polygons.

    20040723 mortene.

========================================================================

013 Using many sub-cubes for a texture slows down visualization to a
    crawl.

    Happens on my box even with just 25 sub-cubes, as for LOBSTER.VOL
    (5x5x1 sub-cubes at the default 64x64x64 pagesize).

    This is a critical bug.

    20040723 mortene.

========================================================================

015 Potentially inefficient utilization of texture memory when using
    3D textures.

    When rendering with 3D textures, all texture sub-cubes are always
    of the same size, which means we will some times (perhaps often)
    use much more texture memory than necessary.

    Consider this example: a voxel set of dimensions 129x129x129, with
    a sub-cube size of 128x128x128 will _not_ use cubes of lesser
    dimensions for the voxel data outside the larger (128x128x128)
    cube, but *all* sub-cubes will be 128x128x128, even for only a
    single "line" of texture, or even just for the sub-cube where just
    the 1x1x1 texture is needed.

    Consider this a high priority item.

    20040817 mortene.

========================================================================

016 Rendering SoObliqueSlice, SoOrthoSlice and SoVolume*Set nodes
    using SoDrawStyle::LINES is not optimal as the volume texture is
    loaded.

    SIMVoleon should not be forced to load volume textures when
    rendering in LINES mode. The LINES rendering is now done by the
    3DTexSubCube/2DTexSubPage class which automatically loads the
    texture when initialized.
    
    20040907 handegar.

========================================================================

017 An empty SoVolumeData node does not seem to be handled well.

    When running the SoGuiExample volumerendering/voleonexplore with a
    non-existent input-file, something is done in either Voleon, SoQt
    or Coin that causes 5 internal Coin warning messages to be printed
    (invalid actions attempted on empty SbBox3f, SbMatrix and
    SbVec3f).

    Seems most likely these are due to something Voleon does wrong, so
    placing the bug report here.

    20040919 mortene.

========================================================================

019 Missing SoTransferFunction should be handled with more grace.

    According to the VolumeViz API-doc, a *missing* SoTransferFunction
    should cause a volume to be rendered with the default
    SoTransferFunction::GREY color map.

    Best way to fix this is probably to kill the
    SoTransferFunctionElement, and replace it with a new element which
    actually carries the current transferfunction on the stack
    (instead of just a pointer back to the SoTransferFunction node).

    20040920 mortene.

========================================================================

020 ''make dist'' not tested, probably not working properly.

    Fix it so it works in accordance with the relevant notes in
    Coin/RELEASE.txt.

    20041010 mortene. 

========================================================================

021 VOL file import is not robust enough.

    Will for instance assert() instead of gracefully handling various
    unexpected conditions. See FIXMEs in readers/VRVOLFileReader.cpp.

    20041014 mortene.

========================================================================

022 Fragment program texture lookups not working correctly.

    Reproduce with the stand-alone example below. The coloring for the
    shape nodes when interpolation==LINEAR and a fragment program is
    activated by CvrCLUT comes out looking very different from when
    the textures are either RGBA textures, or palette textures colored
    by using the GL_EXT_paletted_texture extension.

    Notice that there's one 3D-texture (the SoObliqueSlice) and one
    2D-texture (SoOrthoSlice) in the example, and they both come out
    wrong, in a similar manner.

    This has been tested on at least these OpenGL drivers:

        * Linux NVIDIA 61.11
        * Linux ATI 1.3.4641 X4.3.0-3.14.1

    ..on at least 3 different graphics cards.

----------8<----- [snip] --------------------8<----- [snip] ----------------
#include <Inventor/Qt/SoQt.h>
#include <Inventor/Qt/viewers/SoQtExaminerViewer.h>

#include <Inventor/nodes/SoSeparator.h>

#include <VolumeViz/nodes/SoOrthoSlice.h>
#include <VolumeViz/nodes/SoObliqueSlice.h>
#include <VolumeViz/nodes/SoTransferFunction.h>
#include <VolumeViz/nodes/SoVolumeData.h>
#include <VolumeViz/nodes/SoVolumeRender.h>
#include <VolumeViz/nodes/SoVolumeRendering.h>

static uint8_t* generate8bitVoxelSet(SbVec3s & dim)
{
    const size_t blocksize = dim[0] * dim[1] * dim[2];
    uint8_t * voxels = new uint8_t[blocksize];
    (void)memset(voxels, 0, blocksize);
		        
    float t = 0;

    while (t < 50) {
	SbVec3f v(sin((t + 1.4234) * 1.9) * sin(t) * 0.45 + 0.5,
	cos((t * 2.5) - 10) * 0.45 + 0.5,
	cos((t - 0.23123) * 3) * sin(t + 0.5) * cos(t) * 0.45 + 0.5);

	assert(v[0] < 1.0f && v[1] < 1.0f && v[2] < 1.0f);
	const int nx = int(dim[0] * v[0]);
	const int ny = int(dim[1] * v[1]);
	const int nz = int(dim[2] * v[2]);

	const int memposition = nz*dim[0]*dim[1] + ny*dim[0] + nx;
	voxels[memposition] = (uint8_t)(255.0 * cos(t));

	t += 0.001;
    }

    return voxels;
}

int
main( int argc, char** argv )
{
    QWidget* window = SoQt::init( argv[0] );
    if ( window==NULL ) exit(1);

    SoVolumeRendering::init();

    SoSeparator * root = new SoSeparator;
    root->ref();

    SoVolumeData* volptr = new SoVolumeData();
    root->addChild(volptr);
    SbVec3s dim = SbVec3s(64, 64, 64);
    static uint8_t * voxeldata = generate8bitVoxelSet(dim);
    volptr->setVolumeData(dim, voxeldata, SoVolumeData::UNSIGNED_BYTE);

    SoTransferFunction * transfunc = new SoTransferFunction();
    root->addChild(transfunc);

    root->addChild(new SoObliqueSlice);

    SoOrthoSlice * s = new SoOrthoSlice;
    s->sliceNumber = 25;
    root->addChild(s);

    SoQtExaminerViewer * viewer = new SoQtExaminerViewer(window);
    viewer->setBackgroundColor(SbColor(0.1f, 0.3f, 0.5f));
    viewer->setSceneGraph(root);
	      
    viewer->show();
    SoQt::show(window);
    SoQt::mainLoop();

    delete viewer;
      
    root->unref();
    return 0;
}
----------8<----- [snip] --------------------8<----- [snip] ----------------

    We have seen other programs were 3D-textures comes out ok, but not
    2D-textures, and other examples where the situation is the
    opposite. This may point towards a bug in how the GL state is set
    up.

    20041103 mortene.

========================================================================
