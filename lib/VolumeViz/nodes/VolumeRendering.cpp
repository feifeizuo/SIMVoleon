/**************************************************************************\
 *
 *  This file is part of the SIM Voleon visualization library.
 *  Copyright (C) 2003-2004 by Systems in Motion.  All rights reserved.
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  ("GPL") version 2 as published by the Free Software Foundation.
 *  See the file LICENSE.GPL at the root directory of this source
 *  distribution for additional information about the GNU GPL.
 *
 *  For using SIM Voleon with software that can not be combined with
 *  the GNU GPL, and for taking advantage of the additional benefits
 *  of our support services, please contact Systems in Motion about
 *  acquiring a SIM Voleon Professional Edition License.
 *
 *  See <URL:http://www.coin3d.org/> for more information.
 *
 *  Systems in Motion, Teknobyen, Abels Gate 5, 7030 Trondheim, NORWAY.
 *  <URL:http://www.sim.no/>.
 *
\**************************************************************************/

/*!
  \mainpage

  SIM Voleon is a software development system for aiding in writing 3D
  graphics application containing so-called "volumetric data", as is
  often used in applications targeted at analysis tasks within the oil
  & gas industry (e.g. from seismic measurements), in medical imaging
  (for data generated by e.g. Nuclear Magnetic Resonance, Computer
  Tomography, or ultrasound equipment), and for many other purposes.

  SIM Voleon is an add-on library to Systems in Motion's visualization
  platform technology, known as "Coin". Coin is a high-level 3D
  graphics library with a C++ Application Programming Interface. Its
  target audience is developers of 3D graphics applications worldwide.

  The library has the following major features:

  <ul>

  <li> It is fully portable over the full range of platforms also
  supported by the Coin library, including all versions of Microsoft
  Windows, Apple's Macintosh OS X, Linux, Sun Solaris, SGI IRIX, and
  most other UNIX variants.</li>

  <li> Integrates smoothly with traditional polygonal 3D data
  visualization from the Coin library, in a manner which is effortless
  for the application programmer. </li>

  <li> Provides interaction possibilities for direct queries in the 3D
  scene on the volumetric data. </li>

  <li> Volumes are visualized by using functionality which is assisted
  by dedicated 3D hardware on most modern graphics cards, namely 2D
  texture mapping. </li>

  <li> Higher quality and better performance visualization is
  automatically done on graphics card which supports hardware assisted
  3D texture mapping. </li>
  
  </ul>

  Here's a simple usage example, which sets up a complete environment
  for voxel visualization with the SIM Voleon library:

  \code
  #include <Inventor/Qt/SoQt.h>
  #include <Inventor/Qt/viewers/SoQtExaminerViewer.h>
  #include <Inventor/nodes/SoSeparator.h>
  #include <VolumeViz/nodes/SoTransferFunction.h>
  #include <VolumeViz/nodes/SoVolumeData.h>
  #include <VolumeViz/nodes/SoVolumeRender.h>
  #include <VolumeViz/nodes/SoVolumeRendering.h>
  
  static uint8_t *
  generate8bitVoxelSet(SbVec3s & dim)
  {
    const size_t blocksize = dim[0] * dim[1] * dim[2];
    uint8_t * voxels = new uint8_t[blocksize];
    (void)memset(voxels, 0, blocksize);
  
    float t = 0;
  
    while (t < 50) {
      SbVec3f v(sin((t + 1.4234) * 1.9) * sin(t) * 0.45 + 0.5,
                cos((t * 2.5) - 10) * 0.45 + 0.5,
                cos((t - 0.23123) * 3) * sin(t + 0.5) * cos(t) * 0.45 + 0.5);
  
      assert(v[0] < 1.0f && v[1] < 1.0f && v[2] < 1.0f);
      const int nx = int(dim[0] * v[0]);
      const int ny = int(dim[1] * v[1]);
      const int nz = int(dim[2] * v[2]);
  
      const int memposition = nz*dim[0]*dim[1] + ny*dim[0] + nx;
      voxels[memposition] = (uint8_t)(255.0 * cos(t));
  
      t += 0.001;
    }
  
    return voxels;
  }
  
  int
  main(int argc, char ** argv)
  {
    QWidget * window = SoQt::init(argv[0]);
    SoVolumeRendering::init();
  
    SoSeparator * root = new SoSeparator;
    root->ref();
  
    SbVec3s dim = SbVec3s(64, 64, 64);
    uint8_t * voxeldata = generate8bitVoxelSet(dim);
  
    // Add SoVolumeData to scene graph
    SoVolumeData * volumedata = new SoVolumeData();
    volumedata->setVolumeData(dim, voxeldata, SoVolumeData::UNSIGNED_BYTE);
    root->addChild(volumedata);
  
    // Add TransferFunction (color map) to scene graph
    SoTransferFunction * transfunc = new SoTransferFunction();
    root->addChild(transfunc);
  
    // Add VolumeRender to scene graph
    SoVolumeRender * volrend = new SoVolumeRender();
    root->addChild(volrend);
  
    SoQtExaminerViewer * viewer = new SoQtExaminerViewer(window);
    viewer->setBackgroundColor(SbColor(0.1f, 0.3f, 0.5f));
    viewer->setSceneGraph(root);
  
    viewer->show();
    SoQt::show(window);
    SoQt::mainLoop();
    delete viewer;
  
    root->unref();
    delete[] voxeldata;
  
    return 0;
  }
  \endcode

  \sa The documentation for the \COIN library: <http://doc.coin3d.org/Coin>.
  \sa The documentation for the SoQt library: <http://doc.coin3d.org/SoQt>.
*/

// *************************************************************************

/*!
  \class SoVolumeRendering VolumeViz/nodes/SoVolumeRendering.h
  \brief Abstract base class for all nodes related to volume rendering.

  The sole purpose of this class is really just to initialize the
  volume rendering framework, and to provide a convenient method for
  the application programmer to make queries about the capabilities of
  the underlying visualization library.

  This class should never have been a node class, as it has no
  distinguishing features in that regard. We duplicate this design
  flaw for the sake of being compatible with code written for the TGS
  VolumeViz extension library.
*/

// *************************************************************************

#include <VolumeViz/nodes/SoVolumeRendering.h>
#include <VolumeViz/nodes/SoVolumeData.h>
#include <VolumeViz/elements/SoVolumeDataElement.h>
#include <VolumeViz/elements/SoTransferFunctionElement.h>
#include <VolumeViz/nodes/SoVolumeRender.h>
#include <VolumeViz/nodes/SoTransferFunction.h>
#include <VolumeViz/nodes/SoOrthoSlice.h>
#include <VolumeViz/nodes/SoObliqueSlice.h>
#include <VolumeViz/nodes/SoVolumeIndexedFaceSet.h>
#include <VolumeViz/details/SoVolumeRenderDetail.h>
#include <VolumeViz/details/SoOrthoSliceDetail.h>
#include <VolumeViz/details/SoObliqueSliceDetail.h>
#include <VolumeViz/render/common/CvrTextureObject.h>

#include <Inventor/actions/SoGLRenderAction.h>


// *************************************************************************

SO_NODE_SOURCE(SoVolumeRendering);

// *************************************************************************

class SoVolumeRenderingP {
public:
  static SbBool wasinitialized;
};

SbBool SoVolumeRenderingP::wasinitialized = FALSE;

#define PRIVATE(p) (p->pimpl)
#define PUBLIC(p) (p->master)

// *************************************************************************

SoVolumeRendering::SoVolumeRendering(void)
{
  SO_NODE_CONSTRUCTOR(SoVolumeRendering);

  PRIVATE(this) = NULL; // pimpl-class not yet needed
}

SoVolumeRendering::~SoVolumeRendering()
{
  delete PRIVATE(this);
}

/*!
  Does all necessary class initializations of the volume rendering
  system.

  Application programmers must call this method explicitly at the
  start of the application, before any volume rendering nodes are
  made. It must be invoked \e after SoXt::init() / SoQt::init() /
  SoWin::init(), though.
 */
void
SoVolumeRendering::init(void)
{
  if (SoVolumeRenderingP::wasinitialized) return;
  SoVolumeRenderingP::wasinitialized = TRUE;

  SoVolumeDataElement::initClass();
  SoTransferFunctionElement::initClass();

  SoVolumeRendering::initClass();
  SoVolumeData::initClass();
  SoTransferFunction::initClass();

  SoVolumeRender::initClass();
  SoOrthoSlice::initClass();
  SoObliqueSlice::initClass();
  SoVolumeIndexedFaceSet::initClass();

  SoVolumeRenderDetail::initClass();
  SoOrthoSliceDetail::initClass();
  SoObliqueSliceDetail::initClass();

  // Internal classes follows:

  CvrTextureObject::initClass();
}

/*!
  Sets up initialization for data common to all instances of this
  class, like submitting necessary information to the type system.
*/
void
SoVolumeRendering::initClass(void)
{
  SO_NODE_INIT_CLASS(SoVolumeRendering, SoNode, "SoNode");
}

SoVolumeRendering::HW_SupportStatus
SoVolumeRendering::isSupported(HW_Feature feature)
{
  switch (feature) {

  case SoVolumeRendering::HW_VOLUMEPRO:
    return SoVolumeRendering::NO;

  case SoVolumeRendering::HW_3DTEXMAP:
    // FIXME: update this when support is in place. 20021106 mortene.
    return SoVolumeRendering::NO;

  case SoVolumeRendering::HW_TEXCOLORMAP:
    // FIXME: update this when support is in place. 20021106 mortene.
    return SoVolumeRendering::NO;

  case SoVolumeRendering::HW_TEXCOMPRESSION:
    // FIXME: update this when support is in place. 20021106 mortene.
    return SoVolumeRendering::NO;

  default:
    assert(FALSE && "unknown feature");
    break;
  }

  return SoVolumeRendering::NO;
}
